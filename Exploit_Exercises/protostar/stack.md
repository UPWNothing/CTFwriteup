# Exploit-Exercises Protostar Writeup - Stack
## Before Start
Here are some readings to help you understand the stack
[How to smash stack](http://insecure.org/stf/smashstack.html)

## [Stack0](https://exploit-exercises.com/protostar/stack0/)
This is a very basic overflow. Any input having a length greater than 64 works. 


## [Stack1](https://exploit-exercises.com/protostar/stack1/)
On this level, we have to overwrite the value of 'modified' to 0x61626364, which is "abcd" in ascii characters. Protostar is little endian, so we have to reverse it when we write it into a stack.    
	```./stack1 $(python -c 'print "A"*64+"dcba"')```   


## [Stack2](https://exploit-exercises.com/protostar/stack2/)
This one is almost the same as the previous one. The only difference is the buffer comes from a environment variable called "GREENIE".   
We should set the environment variable and then run the program. The commands are:    
	```
	export GREENIE=$(python -c 'print "A"*64+"0x0a0x0d0x0a0xd"')
	./stack2
	```


## [Stack3](https://exploit-exercises.com/protostar/stack3/)
This time, the varaible can be overwritten is a pointer to a function. So what we need to do is find out the address of win() and use this value to overwrite *fp (in little endian).    
Use command ```objdump -D stack3|grep win```. Now we find the address of win() is 08048424.   
Looking at the source code, we can see the buffer comes from standard input this time. So the command should be:     
	```python -c 'print "A"*64+"\x24\x84\x04\x08"' | ./stack3```    


## [Stack4](https://exploit-exercises.com/protostar/stack4/)
This challenge is about EIP overwrite. There's no variable lying on the buffer again. When we overflow the buffer, we will first overwirte the saved EBP(4 Byte), and saved EIP(4 Byte).    
So in this case, the length of the padding will be 64+4=68. And we also need to get the address of win() just as we did in last challenge. It's 080483f4. Now run it! Ooooooops! It failed!! It apperars that there's something more than saved EBP lying between the buffer and the saved EIP. We can use gdb to find it out. (You can also use a pattern long enough to overwrite the EIP and then locate it, as the program will show the error information.)     
We start gdb and set a breakpoint at main(). Then give serveral "A" as the input. We know it will not work, but it can help us to locate the start address of the buffer. Then we use ```info frame``` to check the address of saved eip. We can see it's at 0xbffff7dc.     
![stack4_1](./images/stack4_1.png)     
Now let's look at the data in this frame. It's easy to find that the buffer start at address 0xbffff790. So we can get the length of our padding by calculating 0xbffff7dc-0xbffff790=76. I also look at why we get 8 bytes more than expected. It saves the address of __libc_csu_init and another 4 null bytes. (I didn't figure out the purpose of it)    
!{stack4_2](./images/stack4_2.png)
The command should be:    
	```python -c 'print "A"*76+"\xf4\x83\x04\x08"' | ./stack4```    


## [Stack5](https://exploit-exercises.com/protostar/stack5/)
## [Stack6](https://exploit-exercises.com/protostar/stack6/)
## [Stack7](https://exploit-exercises.com/protostar/stack7/)
